[TOC]

TCP（Transmission Control Protocol）传输控制协议和 IP（Internet Protocol）因特网协议
TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输

## 1. TCP/IP协议结构
 
基于 TCP/IP 的参考模型可以将协议分为4层结构：**应用层**、**传输层**、**网络层**和**链路层**

### 1.1 物理介质
物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。

TCP/IP 协议栈分为四层，每一层都由特定的协议与对方进行通信，而协议之间的通信最终都要转化为`0`和`1`的电信号，通过物理介质进行传输才能到达对方的电脑，因此物理介质是网络通信的基石。

**TCP/IP 协议的基本框架**
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_1.png)

当通过 http 发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。

>网络通信就好比送快递，商品外面的一层层包裹就是各种协议，协议包含了商品信息、收货地址、收件人、联系方式等，然后还需要配送车、配送站、快递员，商品才能最终到达用户手中。
一般情况下，快递是不能直达的，需要先转发到对应的配送站，然后由配送站再进行派件。
**配送车就是物理介质，配送站就是网关，快递员就是路由器，收货地址就是 IP 地址，联系方式就是 MAC 地址。** 
快递员负责把包裹转发到各个配送站，配送站根据收获地址里的省市区，确认是否需要继续转发到其他配送站，当包裹到达了目标配送站以后，配送站再根据联系方式找到收件人进行派件。

有了整体概念以后，下面我们详细了解一下各层的分工。

### 1.2 链路层  
网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送`0`和`1`是没有意义的。

要传输有意义的数据，就需要以字节为单位对`0`和`1`进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。

以太网规定一组电信号就是一个数据包，**一个数据包被称为一帧**，制定这个规则的协议就是以太网协议。一个完整的以太网数据包如下图所示：

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_2.png)

整个数据帧由**首部**、**数据**和**尾部**三部分组成:
1. 首部固定为 14 个字节，包含了目标 MAC 地址、源 MAC 地址和类型；
2. 数据最短为 46 个字节，最长为 1500 个字节，如果需要传输的数据很长，就必须分割成多个帧进行发送；
3. 尾部固定为 4 个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏。

因此，以太网协议通过对电信号进行分组并形成数据帧，然后通过物理介质把数据帧发送给接收方。那么以太网如何来识接收方的身份呢？

- 以太网协议规定，接入网络的设备都必须安装网络适配器即**网卡**。
- 数据包必须是从一块网卡传送到另一块网卡，而网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的 MAC 地址。
- **MAC 地址是每块网卡的身份标识**，就如同我们身份证上的身份证号码，具有全球唯一性。**MAC 地址采用十六进制标识，共 6 个字节 48 位**，前三个字节是厂商编号，后三个字节是网卡流水号，例如`4C-0F-6E-12-D2-19`。
- 有了 MAC 地址以后，以太网采用**广播**形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标 MAC 地址，然后和自己的 MAC 地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。

所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。

 
### 1.3 网络层

对于上面的过程，有几个细节问题值得我们思考：

>发送者如何知道接收者的MAC地址？
>发送者如何知道接收者和自己同属一个子网？
>如果接收者和自己不在同一个子网，数据包如何发给对方？

为了解决这些问题，网络层引入了三个协议，分别是**IP协议**、**ARP协议**、**路由协议**。

#### 1.3.1 IP协议
通过前面的介绍我们知道，MAC 地址只与厂商有关，与所处的网络无关，所以无法通过 MAC 地址来判断两台主机是否属于同一个子网。

因此，**网络层引入了 IP 协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的 IP 地址**。

IP 地址目前有两个版本，分别是 IPv4 和 IPv6，IPv4 是一个 32 位的地址，常采用 4 个十进制数字表示。**IP 协议将这个 32 位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址**。
由于各类地址的分法不尽相同，以 C 类地址`192.168.24.1`为例，其中前 24 位就是网络地址，后 8 位就是主机地址。因此，**如果两个 IP 地址在同一个子网内，则网络地址一定相同**。为了判断 IP 地址中的网络地址，IP 协议还引入了**子网掩码**，IP 地址和子网掩码通过**按位与运算**后就可以得到网络地址。

由于发送者和接收者的 IP 地址是已知的(应用层的协议会传入)，因此我们只要通过子网掩码对两个 IP 地址进行 AND 运算后就能够判断双方是否在同一个子网了。

##### 1.3.1.1 IP 地址的分类

将 32 位 IP 地址分为 4 段，每段 8 位二进制数

|分类|特征|网络范围|默认掩码|
|----|----|-----|-----|
|A 类地址|第 1 段为网络地址，2-4 段为主机地址|`0-127.x.x.x`|`255.0.0.0/8`|
|B 类地址|1-2 段为网络地址，3-4 段为主机地址|`128-191.x.x.x`|`255.255.0.0/16`|
|C 类地址|1-3 段为网络地址，第 4 段为主机地址|`192-223.x.x.x`|`255.255.255.0/24`|
|D 类地址|组播地址，没有网络地址和主机地址的区别|
|E 类地址|用于科学研究|
 
主机段越多，所能组的网段就越大

特殊地址：`127.0.0.1`（本地回环地址）

公有地址:公有地址（Public address）由 Inter NIC（Internet Network Information Center，因特网信息中心）负责。这些 IP 地址分配给注册并向 Inter NIC 提出申请的组织机构。通过它直接访问因特网。

保留的私网地址（公网上没有服务器使用）:
`10.0.0.0`（A 类）
`172.16.0.0-172.31.0.0`（B 类）
`192.168.0.0-192.168.255.0`（C 类）

##### 1.3.1.2 子网掩码
>子网掩码（Subnet Mask）又叫网络掩码、地址掩码、子网络遮罩。
>它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网（网络地址），以及哪些位标识的是主机（主机地址）的位掩码。

子网掩码不能单独存在，它必须结合 IP 地址一起使用。
子网掩码同 IP 地址一样，是由长度位 32 位的二进制数组成的一个地址。
子网掩码 32 位与 IP 地址 32 位相对应，IP 地址如果某位（二进制）是网络地址，则子网掩码相对应的位的值为`1`，否则为`0`。举例：如`11111111.1111111.1111111.00000000`

子网掩码的作用过程可以简单理解为：
A 主机向B 主机通信，A 和 B 各自的 IP 地址与 A 主机的子网掩码进行 AND 与运算，根据得到的结果划分为
1. 结果相同，则说明 A 主机和 B 主机这两台主机是处于同一个网段，这样 A 可以通过 ARP 广播发现 B 主机的 MAC 地址，B 也可以发现 A 的 MAC 地址来实现正常通信。
2. 结果不相同，则说明 A 主机和 B 主机这两台主机不是处于同一个局域网，ARP 广播会在本地网关终结，这时候 A 主机会把发给 B 主机的数据包先发送给本地网关，网关再根据 B 主机的 IP 地址来查询路由表，再将数据包传递转发，最终送达目的地 B 主机。

- IP 地址与子网掩码做 AND 与运算如下图所示:
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_3.png)
- 从上图可以看到子网掩码是屏蔽一个 IP 地址网络部分的“全`1`”比特模式。
  对于 A 类地址来说默认的子网掩码是`255.0.0.0`
  对于 B 类地址来说默认的子网掩码是`255.255.0.0`
  对于 C 类地址来说默认的子网掩码是`255.255.255.0`

子网掩码的分为默认子网掩码和自定义子网掩码
- 默认子网掩码：未划分子网，对应的网络号都为`1`，主机号都为`0`
- 自定义子网掩码：将一个网络划分子网后，把原本的主机号位置的一部分给了子网号，余下的才是给子网的主机号

##### 1.3.1.3 网关
网关（Gateway）又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连

**网关实质上是一个网络通向其他网络的 IP 地址**。

比如有网络 A 和网络 B:
网络 A 的IP地址范围为`192.168.1.1`-`192.168.1.254`，子网掩码为`255.255.255.0`；
网络 B 的IP地址范围为`192.168.2.1`-`192.168.2.254`，子网掩码为`255.255.255.0`。

在没有路由器的情况下，两个网络之间是不能进行 TCP/IP 通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP 协议也会根据子网掩码`255.255.255.0`判定两个网络中的主机处在不同的网络里。

而要实现这两个网络之间的通信，则必须通过网关。如果网络 A 中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络 B 的网关，网络 B 的网关再转发给网络 B 的某个主机。

所以说，只有设置好网关的 IP 地址，TCP/IP 协议才能实现不同网络之间的相互通信。那么这个 IP 地址是哪台机器的 IP 地址呢？
**网关的 IP 地址是具有路由功能的设备的 IP 地址**，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。
路由器接口使用的 IP 地址可以为本网段中任何一个地址，**不过通常使用该网段的第一个可用地址或最后一个可用地址**，这是为了尽可能避免和本网段中的主机地址冲突

#### 1.3.2 ARP协议
ARP 协议（Address Resolution Protocol）即地址解析协议，是根据 IP 地址获取 MAC 地址的一个网络层协议。其工作原理如下：

>ARP 首先会发起一个请求数据包，数据包的首部包含了目标主机的 IP 地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的 IP 地址，然后和自己的 IP 地址进行比较，如果相同就返回自己的 MAC 地址，如果不同就丢弃该数据包。ARP 接收返回消息，以此确定目标机的 MAC 地址；
>与此同时，ARP 还会将返回的 MAC 地址与对应的 IP 地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。
>cmd 输入`arp -a`就可以查询本机缓存的 ARP 数据。

#### 1.3.3 路由协议
通过 ARP 协议的工作原理可以发现，**ARP 的 MAC 寻址还是局限在同一个子网中**，因此网络层引入了路由协议。

1. 首先通过 IP 协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过 ARP 协议查询对应的 MAC 地址，然后以广播的形式向该子网内的主机发送数据包。

2. 如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标 IP 所在的子网中，然后再通过 ARP 获取目标机 MAC ，最终也是通过广播形式将数据包发送给接收方。

而完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。


#### 1.3.4 IP 数据包

在网络层被包装的数据包就叫 IP 数据包，IPv4 数据包的结构如下图所示：

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_4.png)

IP 数据包由首部和数据两部分组成，首部长度为 20 个字节，主要包含了目标 IP 地址和源 IP 地址，目标 IP 地址是网关路由的线索和依据；
数据部分的最大长度为 65515 字节，理论上一个 IP 数据包的总长度可以达到 65535 个字节，而以太网数据包的最大长度是 1500 个字节，如果超过这个大小，就需要对 IP 数据包进行分割，分成多帧发送。

##### 1.3.4.1 IP 协议头


![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_5.png)

1. 版本号（Version）：
    标识目前采用的 IP 协议的版本，长度 4 比特。一般的值为`0100`（IPv4），`0110`（IPv6）
2. 头部长度（Header Length）：
    该字段表示单位是字节（4 字节，32 bit），一个 IP 头部长度最长为`1111`，即 15*4＝60 个字节。IP 包头最小长度为 20 字节。
3. 服务类型（Type Of Service，TOS）：
    3 位优先权字段(定义包的优先级，现已被忽略) + 4 位 TOS 字段 + 1 位保留字段（须为 0）。
    4 位 TOS 字段分别表示最小时延、最大吞吐量、最高可靠性、最小费用，**其中最多有一个能置为 1**。应用程序根据实际需要来设置 TOS 值，如 ssh 和 telnet 这样的登录程序需要的是最小延时的服务，文件传输 ftp 需要的是最大吞吐量的服务
4. 总长度（Total Length）: 
    指整个 IP 数据包的长度，单位为字节，**即 IP 数据包的最大长度为 65535 字节（2 的 16 次方）**。由于 MTU 的限制，长度超过 MTU 的数据包都将被分片传输，所以实际传输的 IP 分片数据包的长度远远没有达到最大值

接下来三个字段描述如何分片:

5. 标识符（Identifier）：
    长度为 16 bit，该字段和 Flags 和 Fragment Offest 字段联合使用，对较大的上层数据包进行分段（fragment）操作。路由器将一个包拆分后，所有拆分开的小包被标记相同的值，以便目的端设备能够区分哪个包属于被拆分开的包的一部分。
6. 标志符（Flags）：
    长度为 3 bit。该字段第一位不使用。
    第二位是 DF（Don't Fragment）位，DF 位设为 1 时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。
    第三位是 MF（More Fragments）位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的 IP 包的包头中将 MF 位设为 1。
7. 片偏移（Fragment Offest）：
    长度为 13 bit。表示该 IP 包在该组分片包中位置，接收端靠此来组装还原 IP 包。

8. 生存时间（TTL）：
    数据报到达目的地之前允许经过的路由器跳数。TTL 值被发送端设置，常设置为 64。
    数据报在转发过程中每经过一个路由该值就被路由器减 1，当 TTL 值为 0 时，路由器就将该数据包丢弃，并向源端发送一个 ICMP 差错报文。
    TTL 可以防止数据报陷入路由循环。
9. 协议（Protocol）：
    区分 IP 协议上的上层协议。在 Linux 系统的 /etc/protocols 文件中定义了所有上层协议对应的协议字段，ICMP 为 1，TCP 为 6，UDP 为 17。
10. 头部校验和（Header Checksum）：
    长度为 16 位。用来做 IP 头部的正确性检测（CRC 算法校验），但不包含数据部分。 
    因为每个路由器要改变 TTL 的值，所以路由器会为每个通过的数据包重新计算这个值。
11. 源 IP 地址和目的 IP 地址（Source and Destination Addresses）： 
    表示数据报的发送端和接收端。一般情况下这两个地址在整个数据报传递过程中保持不变，不论中间经过多少个路由器

综上所述，网络层的主要工作是定义网络地址，区分网段，子网内 MAC 寻址，对于不同子网的数据包进行路由。

### 1.4 传输层
链路层定义了主机的身份，即 MAC 地址。网络层定义了 IP 地址，明确了主机所在的网段。有了这两个地址，数据包就从可以从一个主机发送到另一台主机。
但实际上数据包是从一个主机的某个**应用程序**发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。

因此传输层引入了 UDP 协议来解决这个问题，**为了给每个应用程序标识身份，UDP 协议定义了端口**，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP 定义的数据包就叫做 UDP 数据包，结构如下所示：

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_6.png)

- UDP 数据包由首部和数据两部分组成，首部长度为 8 个字节，主要包括源端口和目标端口。
- 数据最大为 65527 个字节，整个数据包的长度最大可达到 65535 个字节。

UDP协议比较简单，实现容易，但它**没有确认机制**， 数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。
TCP 即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说 TCP 就是有确认机制的 UDP 协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。
为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了**三次对话的确认机制**，也就是说，在正式收发数据前，必须和对方建立可靠的连接。由于建立过程较为复杂，我们在这里做一个形象的描述：

>主机A：我想发数据给你，可以么？
>主机B：可以，你什么时候发？
>主机A：我马上发，你接着

经过三次对话之后，主机 A 才会向主机 B 发送正式数据，**而 UDP 是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发过去了**。所以 TCP 能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比 UDP，TCP 实现过程复杂，消耗连接资源多，传输速度慢。

TCP 数据包和 UDP 一样，都是由首部和数据两部分组成，唯一不同的是，**TCP 数据包没有长度限制**，理论上可以无限长，但是为了保证网络的效率，**通常 TCP 数据包的长度不会超过IP数据包的长度**，以确保单个 TCP 数据包不必再分割。

#### 1.4.1 DNS
DNS（Domain Name System，域名系统），**因特网上作为域名和 IP 地址相互映射的一个分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。
通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS 协议运行在 UDP 协议之上，使用端口号 53。

#### 1.4.2 TCP 连接的建立与终止

##### 1.4.2.1 TCP 三次握手

##### 1.4.2.2 TCP 四次挥手





总结一下，传输层的主要工作是定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。

### 1.5 应用层

理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差。
因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于 B/S 架构之间的数据通信，其报文格式如下：

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/TCP_7.png)

- 在 Resquest Headers 中，Accept 表示客户端期望接收的数据格式，而 ContentType 则表示客户端发送的数据格式；
- 在 Response Headers 中，ContentType 表示服务端响应的数据格式，这里定义的格式，一般是和  Resquest Headers 中 Accept 定义的格式是一致的。

有了这个规范以后，服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。

所以应用层的主要工作就是定义数据格式并按照对应的格式解读数据。

#### 1.5.1 HTTP 协议


### 1.6 总结

首先我们梳理一下每层模型的职责：
- 链路层：对`0`和`1`进行分组，定义数据帧，确认主机的物理地址，传输数据；
- 网络层：定义 IP 地址，确认主机所在的网络位置，并通过 IP 进行 MAC 寻址，对外网数据包进行路由转发；
- 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
- 应用层：定义数据格式，并按照对应的格式解读数据。

然后再把每层模型的职责串联起来，用一句通俗易懂的话讲就是：当你输入一个网址并按下回车键的时候，
>1. 首先，应用层协议对该请求包做了格式定义；
>2. 紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；
>3. 然后网络协议加上了双方的IP地址，确认了双方的网络位置；
>4. 最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。
>5. 目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。


















