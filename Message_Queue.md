
[TOC]

# 消息队列

## 1. 什么是消息队列
这样的场景你一定不陌生：小王到 M 记点餐之后，服务员给了他一个号牌，并让他在柜台桌子前方等待叫号取餐。每个人都按照自己付款拿到的号牌顺序排队等叫号。即使店里人再多，也不会显得没有秩序。

在上述场景中，柜台其实就充当了一个消息队列。小王等生产者把订餐的消息发送到柜台即消息队列里，又从其中取了餐即消费了消息，可以说这就是消息队列的一个完整走向——消息被发送到队列中，又成功被消费者消费。

“消息队列”是在消息的传输过程中保存消息的容器，队列的主要目的是提供路由并保证消息的传递。如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。
<br>

消息队列，一般我们会简称它为`MQ(Message Queue)`

> 分解来看：队列`(Queue)`是一种先进先出的数据结构

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/queue.png)

> 消息队列`MQ(Message Queue)`就可以简单理解为：把要传输的数据放在队列中

我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用
- 把数据放到消息队列叫做生产者(producer)
- 从消息队列里边取数据叫做消费者(consumer)
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/MQ_1.png)



> 消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有`ActiveMQ`，`RabbitMQ`，`Kafka`，`RocketMQ`
<br>

## 2. 为什么要使用消息队列

使用消息队列主要有2点好处：
1. 降低系统耦合性（解耦）
2. 通过异步处理提高系统性能（削峰、减少响应所需时间）

#### 2.1 解耦

**如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。**

##### 2.1.1 举例1
- step1:
  现在我有一个系统 A，系统 A 可以产生一个`userId`
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_1.png)
<br>

- step2: 
  然后，现在有系统 B 和系统 C 都需要这个`userId`去做相关的操作
  此时系统A给系统 B 和系统 C 传入userId这个值
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_2.png)
伪代码可以如下所示：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_3.png)
结构图如下所示：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_4.png)
<br>

- step3: 
  ok，一切平安无事度过了几个天。  
  某一天，系统 B 的负责人告诉系统 A 的负责人，现在系统B的`SystemBNeed2do(String userId)`这个接口不再使用了，让系统 A 别去调它了。
  于是，系统A的负责人说 “好的，那我就不调用你了”，于是就把调用系统B接口的代码给删掉了：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_5.png)
<br>

- step4:
  又过了几天，系统 D 的负责人接了个需求，也需要用到系统 A 的`userId`，于是就跑去跟系统 A 的负责人说："老哥，我要用到你的`userId`，你调一下我的接口吧"
  于是系统 A 说："没问题的，这就搞"
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_6.png)
  然后，系统 A 的代码如下
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_7.png)
<br>

- step5:
  时间飞逝：
  又过了几天，系统 E 的负责人过来了，告诉系统 A，需要 userId。
  又过了几天，系统 B 的负责人过来了，告诉系统 A，还是重新掉那个接口吧。
  又过了几天，系统 F 的负责人过来了，告诉系统 A，需要 userId。  
  ……  
  于是系统 A 的负责人，每天都被这给骚扰着，改来改去，改来改去…….  
  还有另外一个问题，调用系统 C 的时候，如果系统 C 挂了，系统 A 还得想办法处理。如果调用系统 D 时，由于网络延迟，请求超时了，那系统 A 是反馈 fail 还是重试？？  
  最后，系统 A 的负责人，觉得隔一段时间就改来改去，没意思，于是就跑路了。 
<br>

- step6: 
  然后，公司招来一个大佬，大佬经过几天熟悉，上来就说：
  **将系统 A 的`userId`写到消息队列中，这样系统 A 就不用经常改动了**
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_8.png)

系统 A 将`userId`写到消息队列中，系统 C 和系统 D 从消息队列中拿数据。这样有什么好处？

- 系统 A 只负责把数据写到队列中，谁想要或不想要这个数据(消息)，系统 A 一点都不关心。

- 即便现在系统 D 不想要`userId`这个数据了，系统B又突然想要`userId`这个数据了，都跟系统 A 无关，系统 A 一点代码都不用改。

- 系统 D 拿`userId`不再经过系统 A，而是从消息队列里边拿。系统 D 即便挂了或者请求超时，都跟系统 A 无关，只跟消息队列有关。

这样一来，系统 A 与系统 B、C、D 都解耦了。
<br>

##### 2.1.2 举例2
场景说明：订单库存系统
用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_12.png)
传统做法的缺点：
- 订单系统与库存系统耦合
- 假如库存系统无法访问，则订单调用库存接口将失败，从而导致订单失败

引入消息队列后的方案：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_13.png)
- 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功并继续处理下一个用户订单
- 库存系统：订阅下单的消息，采用`pull/push`的方式，获取下单信息，库存系统根据下单信息，进行库存操作
- 在下单时库存系统不能正常使用时，也不影响正常下单，**因为下单后，订单系统写入消息队列就不再关心其他的后续操作了**。实现订单系统与库存系统的应用解耦
<br>

##### 2.1.3 总结
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_9.png)
1. 消息队列利用**发布-订阅**模式工作：消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。
2. 消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，**并不需要知道该消息从何而来**。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的**可扩展性设计**。
3. 消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此**基于事件（消息对象）驱动的业务架构可以是一系列流程**。
4. 分布式：为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。**在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息**。


- 备注：
  消息队列并不是只能利用**发布-订阅**模式工作，只不过在**解耦**这个特定业务环境下是使用**发布-订阅**模式的。
  除了**发布-订阅**模式，还有**点对点**订阅模式（一个消息只有一个消费者），另外这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。
<br>

#### 2.2 异步、削峰

##### 2.2.1 异步
场景说明：系统 A 还是直接调用系统 B、C、D，采用同步处理
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/asynchronous_1.png)
伪代码如下：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/asynchronous_2.png)

假设系统A运算出`userId`具体的值需要50ms，
调用系统B的接口需要300ms，
调用系统C的接口需要300ms，
调用系统D的接口需要300ms。
那么这次请求就需要50+300+300+300=950ms

并且我们得知，系统 A 做的是主要的业务，而系统 B、C、D 是非主要的业务。
比如系统 A 处理的是订单下单，而系统 B 处理的是订单下单成功后发送一条短信告诉具体的用户此订单已成功，而系统 C 和系统 D 也是处理一些小事而已，这样就不需要同步处理了。

那么此时，为了提高用户体验和吞吐量，其实可以异步地调用系统 B、C、D 的接口。所以，我们可以弄成是这样的：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/asynchronous_3.png)
- 系统A执行完了以后，将userId写到消息队列中，然后就直接返回了(至于其他的操作，则异步处理)。
- 本来整个请求需要用950ms(同步)，现在将调用其他系统接口异步化，从请求到返回只需要100ms(异步)

强弱依赖梳理，将非关键调用链路的操作异步化，提升整体系统的吞吐能力

##### 2.2.2 削峰
场景说明：现在我们每个月要搞一次大促，大促期间的并发可能会很高的，比如每秒 3000 个请求。假设我们现在有两台机器处理请求，并且每台机器只能每次处理 1000 个请求。
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_1.png)

那多出来的 1000 个请求，可能就把我们整个系统给搞崩了…所以，有一种办法，我们可以写到消息队列中。
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_2.png)

系统 B 和系统 C 根据自己能够处理的请求数去消息队列中拿数据，这样即便有每秒有 8000 个请求，那只是把请求放在消息队列中，去拿消息队列的消息由系统自己去控制，这样就不会把整个系统给搞崩。
消息队列相当于设置了流量缓冲池，可以让 B、C 系统按照自身吞吐能力进行消费，不被冲垮。

##### 2.2.3 实际应用场景
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_3.png)

- 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。
- 在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。
- 由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 
举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_4.png)

- 注意：因为用户请求数据写入消息队列之后就立即返回给用户了，但是**请求数据在后续的业务校验、写数据库等操作中可能失败**。
因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。


## 3. 使用消息队列带来的一些问题

既然 MQ 是互联网分层架构中的解耦利器，那所有通讯都使用 MQ 岂不是很好? 这是一个严重的误区，调用与被调用的关系，是无法被 MQ 取代的。

1. 系统复杂性提高：加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证。
2. 系统可用性降低：系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！
3. 一致性问题：上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!
4. 消息传递路径更长，延时会增加

举例：
用户登录场景，登录页面调用 passport 服务，passport 服务的执行结果直接影响登录结果，此处的“登录页面”与“passport服务”就必须使用调用关系，而不能使用 MQ 通信。

调用方实时依赖执行结果的业务场景，请使用调用，而不是 MQ。


## 4. 消息队列工作原理

#### 4.1 消息生产者、消费者、队列
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/MQ_principle_1.png)
- 消息生产者`Producer`：发送消息到消息队列。
- 消息消费者`Consumer`：从消息队列接收消息。
- `Broker`：概念来自与 Apache ActiveMQ，**指 MQ 的服务端，帮你把消息从发送端传送到接收端**。
- 消息队列`MQ`：一个先进先出的消息存储区域。消息按照顺序发送接收，一旦消息被消费处理，该消息将从队列中删除。

设计 Broker 的主要原因：

（1）消息的转储：在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。

（2）规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。

（3）简单理解就是一个消息转发器，把一次 RPC 做成两次 RPC。发送者把消息投递到 Broker，Broker 再将消息转发一手到接收端。总结起来就是两次 RPC 加一次转储，如果要做消费确认，则是三次 RPC。

#### 4.2 两种消息模型
1. 点对点消息队列模型（ point to point， queue ）
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/MQ_principle_2.png)

特点：
（1）消息生产者向一个特定的队列发送消息，消息消费者从该队列中接收消息
（2）每个消息只有一个消费者（即一旦被消费，消息就不再在消息队列中)，消息不可以被重复消费
（3）消息的生产者和消费者可以不同时处于运行状态，在时间上没有依赖性
（4）每一个成功处理的消息都由消息消费者签收确认（Acknowledge）

2. 发布订阅消息模型 - Topic

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/MQ_principle_3.png)

发布订阅模型包含三个角色：
- 主题（Topic）
- 发布者（Publisher）
- 订阅者（Subscriber）
多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。

特点：
（1）每个消息可以有多个消费者，消息可以重复消费
（2）必须先订阅，再发送消息，而后接收订阅的消息，这个顺序必须保证
（3）发布者和订阅者之间有时间上的依赖性
（4）针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
（5）为了消费消息，订阅者必须保持运行的状态。

3. 两种消息模型的区别：
点对点消息队列模型中消息不可以被重复消费，而发布订阅消息模型中消息可以重复被消费

#### 4.3 消息队列的一些处理机制

##### 4.3.1 消息的 ACK 确认机制

- 为了**保证消息不丢失**，消息队列提供了消息 Acknowledge 机制，即 ACK 机制
- 当 Consumer 确认消息已经被消费处理，发送一个 ACK 给消息队列，此时消息队列便可以删除这个消息了。
- 如果 Consumer 宕机/关闭，没有发送 ACK，消息队列将认为这个消息没有被处理，会将这个消息重新发送给其他的 Consumer 重新消费处理。

##### 4.3.2 消息的事务支持

消息的收发处理支持事务，例如：在任务中心场景中，一次处理可能涉及多个消息的接收、处理，这处于同一个事务范围内，如果一个消息处理失败，事务回滚，消息重新回到队列中。

##### 4.3.3 消息的持久化

消息的持久化，对于一些关键的核心业务来说是非常重要的，启用消息持久化后，消息队列宕机重启后，消息可以从持久化存储恢复，消息不丢失，可以继续消费处理。


## 总结

使用消息队列的好处
>解耦
在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。

>冗余
有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。

>扩展性
因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。

>灵活性 & 峰值处理能力
在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

>可恢复性
系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

>顺序保证
在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka 保证一个 Partition 内的消息的有序性。

>缓冲
在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。

>异步通信
很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
