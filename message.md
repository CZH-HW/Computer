
[TOC]

# 消息队列

## 1. 什么是消息队列
这样的场景你一定不陌生：小王到M记点餐之后，服务员给了他一个号牌，并让他在柜台桌子前方等待叫号取餐。每个人都按照自己付款拿到的号牌顺序排队等叫号。即使店里人再多，也不会显得没有秩序。
在上述场景中，柜台其实就充当了一个消息队列。小王等生产者把订餐的消息发送到柜台即消息队列里，又从其中取了餐即消费了消息，可以说这就是消息队列的一个完整走向——消息被发送到队列中，又成功被消费者消费。“消息队列”是在消息的传输过程中保存消息的容器，队列的主要目的是提供路由并保证消息的传递。如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。

消息队列，一般我们会简称它为`MQ(Message Queue)`

> 分解来看：队列`(Queue)`是一种先进先出的数据结构

![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/queue.png)

> 消息队列`MQ(Message Queue)`就可以简单理解为：把要传输的数据放在队列中

我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用
- 把数据放到消息队列叫做生产者(producer)
- 从消息队列里边取数据叫做消费者(consumer)
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/MQ_1.png)



> 消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有`ActiveMQ`，`RabbitMQ`，`Kafka`，`RocketMQ`

## 2. 为什么要使用消息队列
使用消息队列主要有2点好处：
1. 降低系统耦合性（解耦）
2. 通过异步处理提高系统性能（削峰、减少响应所需时间）

#### 2.1 解耦

**如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。**

##### 2.1.1 举例1
- step1:
  现在我有一个系统A，系统A可以产生一个`userId`
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_1.png)
<br>

- step2: 
  然后，现在有系统B和系统C都需要这个`userId`去做相关的操作
  此时系统A给系统B和系统C传入userId这个值
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_2.png)
伪代码可以如下所示：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_3.png)
结构图如下所示：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_4.png)
<br>

- step3: 
  ok，一切平安无事度过了几个天。  
  某一天，系统B的负责人告诉系统A的负责人，现在系统B的`SystemBNeed2do(String userId)`这个接口不再使用了，让系统A别去调它了。
  于是，系统A的负责人说 “好的，那我就不调用你了”，于是就把调用系统B接口的代码给删掉了：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_5.png)
<br>

- step4:
  又过了几天，系统D的负责人接了个需求，也需要用到系统A的`userId`，于是就跑去跟系统A的负责人说："老哥，我要用到你的`userId`，你调一下我的接口吧"
  于是系统A说："没问题的，这就搞"
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_6.png)
  然后，系统A的代码如下
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_7.png)
<br>

- step5:
  时间飞逝：
  又过了几天，系统E的负责人过来了，告诉系统A，需要userId。
  又过了几天，系统B的负责人过来了，告诉系统A，还是重新掉那个接口吧。
  又过了几天，系统F的负责人过来了，告诉系统A，需要userId。  
  ……  
  于是系统A的负责人，每天都被这给骚扰着，改来改去，改来改去…….  
  还有另外一个问题，调用系统C的时候，如果系统C挂了，系统A还得想办法处理。如果调用系统D时，由于网络延迟，请求超时了，那系统A是反馈fail还是重试？？  
  最后，系统A的负责人，觉得隔一段时间就改来改去，没意思，于是就跑路了。 
<br>

- step6: 
  然后，公司招来一个大佬，大佬经过几天熟悉，上来就说：
  **将系统A的`userId`写到消息队列中，这样系统A就不用经常改动了**
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_8.png)

系统A将`userId`写到消息队列中，系统C和系统D从消息队列中拿数据。这样有什么好处？

- 系统A只负责把数据写到队列中，谁想要或不想要这个数据(消息)，系统A一点都不关心。

- 即便现在系统D不想要`userId`这个数据了，系统B又突然想要`userId`这个数据了，都跟系统A无关，系统A一点代码都不用改。

- 系统D拿`userId`不再经过系统A，而是从消息队列里边拿。系统D即便挂了或者请求超时，都跟系统A无关，只跟消息队列有关。

这样一来，系统A与系统B、C、D都解耦了。
<br>

##### 2.1.2 举例2
场景说明：订单库存系统
用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_12.png)
传统做法的缺点：
- 订单系统与库存系统耦合
- 假如库存系统无法访问，则订单调用库存接口将失败，从而导致订单失败

引入消息队列后的方案：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_13.png)
- 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功并继续处理下一个用户订单
- 库存系统：订阅下单的消息，采用`pull/push`的方式，获取下单信息，库存系统根据下单信息，进行库存操作
- 在下单时库存系统不能正常使用时，也不影响正常下单，**因为下单后，订单系统写入消息队列就不再关心其他的后续操作了**。实现订单系统与库存系统的应用解耦
<br>

##### 2.1.3 总结
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/decoupling_9.png)
1. 消息队列利用**发布-订阅**模式工作：消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。
2. 消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，**并不需要知道该消息从何而来**。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的**可扩展性设计**。
3. 消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此**基于事件（消息对象）驱动的业务架构可以是一系列流程**。
4. 分布式：为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。**在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息**。


- 备注：
  消息队列并不是只能利用**发布-订阅**模式工作，只不过在**解耦**这个特定业务环境下是使用**发布-订阅**模式的。
  除了**发布-订阅**模式，还有**点对点**订阅模式（一个消息只有一个消费者），另外这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。
<br>

#### 2.2 异步、削峰

##### 2.2.1 异步
场景说明：系统A还是直接调用系统B、C、D，采用同步处理
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/asynchronous_1.png)
伪代码如下：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/asynchronous_2.png)

假设系统A运算出`userId`具体的值需要50ms，
调用系统B的接口需要300ms，
调用系统C的接口需要300ms，
调用系统D的接口需要300ms。
那么这次请求就需要50+300+300+300=950ms

并且我们得知，系统A做的是主要的业务，而系统B、C、D是非主要的业务。
比如系统A处理的是订单下单，而系统B处理的是订单下单成功后发送一条短信告诉具体的用户此订单已成功，而系统C和系统D也是处理一些小事而已，这样就不需要同步处理了。

那么此时，为了提高用户体验和吞吐量，其实可以异步地调用系统B、C、D的接口。所以，我们可以弄成是这样的：
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/asynchronous_3.png)
- 系统A执行完了以后，将userId写到消息队列中，然后就直接返回了(至于其他的操作，则异步处理)。
- 本来整个请求需要用950ms(同步)，现在将调用其他系统接口异步化，从请求到返回只需要100ms(异步)

强弱依赖梳理，将非关键调用链路的操作异步化，提升整体系统的吞吐能力

##### 2.2.2 削峰
场景说明：现在我们每个月要搞一次大促，大促期间的并发可能会很高的，比如每秒3000个请求。假设我们现在有两台机器处理请求，并且每台机器只能每次处理1000个请求。
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_1.png)

那多出来的1000个请求，可能就把我们整个系统给搞崩了…所以，有一种办法，我们可以写到消息队列中。
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_2.png)

系统B和系统C根据自己的能够处理的请求数去消息队列中拿数据，这样即便有每秒有8000个请求，那只是把请求放在消息队列中，去拿消息队列的消息由系统自己去控制，这样就不会把整个系统给搞崩。
消息队列相当于设置了流量缓冲池，可以让B、C系统按照自身吞吐能力进行消费，不被冲垮。

##### 2.2.3 实际应用场景
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_3.png)

- 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。
- 在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。
- 由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 
举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/peak_clipping_4.png)

注意：因为用户请求数据写入消息队列之后就立即返回给用户了，但是**请求数据在后续的业务校验、写数据库等操作中可能失败**。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。


## 3. 使用消息队列带来的一些问题

1. 系统可用性降低：系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！
2. 系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
3. 一致性问题：上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!


## 4. 消息队列工作原理
针对上面的问题，消息队列

消息队列已经逐渐成为分布式应用场景、内部通信、以及秒杀等高并发业务场景的核心手段，它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能

无论是 RabbitMQ、RocketMQ、ActiveMQ、Kafka还是其它等，都有的一些基本原理、术语、机制等

#### 4.1 消息生产者、消息者、队列
![](https://github.com/CZH-HW/CloudImg/raw/master/Comp/MQ_principle_1.png)
- 消息生产者`Producer`：发送消息到消息队列。
- 消息消费者`Consumer`：从消息队列接收消息。
- `Broker`：概念来自与Apache ActiveMQ，指MQ的服务端，帮你把消息从发送端传送到接收端。
- 消息队列`MQ`：一个先进先出的消息存储区域。消息按照顺序发送接收，一旦消息被消费处理，该消息将从队列中删除。



















## 5. Kafka
Kafka是分布式的发布—订阅消息系统。它最初由LinkedIn(领英)公司发布，使用Scala语言编写，与2010年12月份开源，成为Apache的顶级项目。Kafka是一个高吞吐量的、持久性的、分布式发布订阅消息系统。它主要用于处理活跃的数据(登录、浏览、点击、分享、喜欢等用户行为产生的数据)。
三大特点：
1. 高吞吐量（生产消费）
   可以满足每秒百万级别消息的生产和消费。
2. 持久性（中间存储）
   有一套完善的消息存储机制，确保数据的高效安全的持久化。
3. 分布式（整体健壮性）
   基于分布式的扩展和容错机制；Kafka的数据都会复制到几台服务器上。当某一台故障失效时，生产者和消费者转而使用其它的机器。

















## 5. 待思考和补充
1.Client如何将消息可靠投递到MQ

Client发送消息给MQ——>MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息——>Client收到Ack消息后，认为消息已经投递成功。

2.MQ如何将消息可靠投递到Client

1.MQ将消息push给Client（或Client来pull消息）

2.Client得到消息并做完业务逻辑

3.Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题；

4.MQ将已消费的消息删除